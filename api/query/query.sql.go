// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExpensePlan = `-- name: CreateExpensePlan :one
INSERT INTO expense_plan (
   title,
   category,
   amount_planned,
   recurrency_type,
   recurrency_interval,
   created_at,
   updated_at
) VALUES (
   $1,
   $2,
   $3,
   $4,
   $5,
   NOW(),
   NOW()
)
RETURNING expense_plan_id, title, amount_planned, recurrency_type, recurrency_interval, category, created_at, updated_at, first_expense_plan_record_id, last_expense_plan_record_id
`

type CreateExpensePlanParams struct {
	Title              string
	Category           NullExpensePlanCategory
	AmountPlanned      int32
	RecurrencyType     NullRecurrencyType
	RecurrencyInterval int32
}

func (q *Queries) CreateExpensePlan(ctx context.Context, arg CreateExpensePlanParams) (ExpensePlan, error) {
	row := q.db.QueryRow(ctx, createExpensePlan,
		arg.Title,
		arg.Category,
		arg.AmountPlanned,
		arg.RecurrencyType,
		arg.RecurrencyInterval,
	)
	var i ExpensePlan
	err := row.Scan(
		&i.ExpensePlanID,
		&i.Title,
		&i.AmountPlanned,
		&i.RecurrencyType,
		&i.RecurrencyInterval,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstExpensePlanRecordID,
		&i.LastExpensePlanRecordID,
	)
	return i, err
}

const createExpensePlanRecord = `-- name: CreateExpensePlanRecord :one
INSERT INTO expense_plan_record (
   expense_plan_id,
   amount_paid,
   payment_date,
   paid_date,
   expense_plan_sequence,
   created_at,
   updated_at
) VALUES (
   $1,
   $2,
   $3,
   $4,
   COALESCE((
      SELECT r.expense_plan_sequence
      FROM expense_plan_record r
      WHERE r.expense_plan_id = $1
      AND r.payment_date      < $3
      ORDER BY r.payment_date DESC
      LIMIT 1
   ), 0) + 1,
   NOW(),
   NOW()
)
RETURNING expense_plan_record_id, expense_plan_id, amount_paid, payment_date, paid_date, expense_plan_sequence, created_at, updated_at
`

type CreateExpensePlanRecordParams struct {
	ExpensePlanID int32
	AmountPaid    int32
	PaymentDate   pgtype.Timestamptz
	PaidDate      pgtype.Timestamptz
}

func (q *Queries) CreateExpensePlanRecord(ctx context.Context, arg CreateExpensePlanRecordParams) (ExpensePlanRecord, error) {
	row := q.db.QueryRow(ctx, createExpensePlanRecord,
		arg.ExpensePlanID,
		arg.AmountPaid,
		arg.PaymentDate,
		arg.PaidDate,
	)
	var i ExpensePlanRecord
	err := row.Scan(
		&i.ExpensePlanRecordID,
		&i.ExpensePlanID,
		&i.AmountPaid,
		&i.PaymentDate,
		&i.PaidDate,
		&i.ExpensePlanSequence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExpensePlan = `-- name: DeleteExpensePlan :execrows
DELETE FROM expense_plan WHERE expense_plan_id = $1
`

func (q *Queries) DeleteExpensePlan(ctx context.Context, expensePlanID int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpensePlan, expensePlanID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpensePlanRecord = `-- name: DeleteExpensePlanRecord :execrows
DELETE FROM expense_plan_record WHERE expense_plan_record_id = $1
`

func (q *Queries) DeleteExpensePlanRecord(ctx context.Context, expensePlanRecordID int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpensePlanRecord, expensePlanRecordID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getExpensePlan = `-- name: GetExpensePlan :one
SELECT 
   pla.expense_plan_id, pla.title, pla.amount_planned, pla.recurrency_type, pla.recurrency_interval, pla.category, pla.created_at, pla.updated_at, pla.first_expense_plan_record_id, pla.last_expense_plan_record_id,
   frec.amount_paid as first_amount_paid,
   frec.payment_date as first_payment_date,
   frec.paid_date as first_paid_date,
   frec.expense_plan_sequence as first_expense_plan_sequence,
   lrec.amount_paid as last_amount_paid,
   lrec.payment_date as last_payment_date,
   lrec.paid_date as last_paid_date,
   lrec.expense_plan_sequence as last_expense_plan_sequence
FROM expense_plan pla
LEFT JOIN expense_plan_record frec ON pla.first_expense_plan_record_id = frec.expense_plan_record_id
LEFT JOIN expense_plan_record lrec ON pla.last_expense_plan_record_id = lrec.expense_plan_record_id
WHERE pla.expense_plan_id = $1
`

type GetExpensePlanRow struct {
	ExpensePlanID            int32
	Title                    string
	AmountPlanned            int32
	RecurrencyType           NullRecurrencyType
	RecurrencyInterval       int32
	Category                 ExpensePlanCategory
	CreatedAt                pgtype.Timestamptz
	UpdatedAt                pgtype.Timestamptz
	FirstExpensePlanRecordID pgtype.Int4
	LastExpensePlanRecordID  pgtype.Int4
	FirstAmountPaid          pgtype.Int4
	FirstPaymentDate         pgtype.Timestamptz
	FirstPaidDate            pgtype.Timestamptz
	FirstExpensePlanSequence pgtype.Int4
	LastAmountPaid           pgtype.Int4
	LastPaymentDate          pgtype.Timestamptz
	LastPaidDate             pgtype.Timestamptz
	LastExpensePlanSequence  pgtype.Int4
}

func (q *Queries) GetExpensePlan(ctx context.Context, expensePlanID int32) (GetExpensePlanRow, error) {
	row := q.db.QueryRow(ctx, getExpensePlan, expensePlanID)
	var i GetExpensePlanRow
	err := row.Scan(
		&i.ExpensePlanID,
		&i.Title,
		&i.AmountPlanned,
		&i.RecurrencyType,
		&i.RecurrencyInterval,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstExpensePlanRecordID,
		&i.LastExpensePlanRecordID,
		&i.FirstAmountPaid,
		&i.FirstPaymentDate,
		&i.FirstPaidDate,
		&i.FirstExpensePlanSequence,
		&i.LastAmountPaid,
		&i.LastPaymentDate,
		&i.LastPaidDate,
		&i.LastExpensePlanSequence,
	)
	return i, err
}

const getExpensePlanRecord = `-- name: GetExpensePlanRecord :one
SELECT 
   rec.expense_plan_record_id, rec.expense_plan_id, rec.amount_paid, rec.payment_date, rec.paid_date, rec.expense_plan_sequence, rec.created_at, rec.updated_at,
   ep.title as expense_plan_title,
   ep.category as expense_plan_category,
   ep.amount_planned as expense_plan_amount_planned,
   ep.recurrency_type as expense_plan_recurrency_type,
   ep.recurrency_interval as expense_plan_recurrency_interval
FROM expense_plan_record rec
LEFT JOIN expense_plan ep ON rec.expense_plan_id = ep.expense_plan_id
WHERE rec.expense_plan_record_id = $1
`

type GetExpensePlanRecordRow struct {
	ExpensePlanRecordID           int32
	ExpensePlanID                 int32
	AmountPaid                    int32
	PaymentDate                   pgtype.Timestamptz
	PaidDate                      pgtype.Timestamptz
	ExpensePlanSequence           int32
	CreatedAt                     pgtype.Timestamptz
	UpdatedAt                     pgtype.Timestamptz
	ExpensePlanTitle              pgtype.Text
	ExpensePlanCategory           NullExpensePlanCategory
	ExpensePlanAmountPlanned      pgtype.Int4
	ExpensePlanRecurrencyType     NullRecurrencyType
	ExpensePlanRecurrencyInterval pgtype.Int4
}

func (q *Queries) GetExpensePlanRecord(ctx context.Context, expensePlanRecordID int32) (GetExpensePlanRecordRow, error) {
	row := q.db.QueryRow(ctx, getExpensePlanRecord, expensePlanRecordID)
	var i GetExpensePlanRecordRow
	err := row.Scan(
		&i.ExpensePlanRecordID,
		&i.ExpensePlanID,
		&i.AmountPaid,
		&i.PaymentDate,
		&i.PaidDate,
		&i.ExpensePlanSequence,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpensePlanTitle,
		&i.ExpensePlanCategory,
		&i.ExpensePlanAmountPlanned,
		&i.ExpensePlanRecurrencyType,
		&i.ExpensePlanRecurrencyInterval,
	)
	return i, err
}

const listExpensePlanRecords = `-- name: ListExpensePlanRecords :many
SELECT 
   rec.expense_plan_record_id, rec.expense_plan_id, rec.amount_paid, rec.payment_date, rec.paid_date, rec.expense_plan_sequence, rec.created_at, rec.updated_at,
   ep.title as expense_plan_title,
   ep.category as expense_plan_category,
   ep.amount_planned as expense_plan_amount_planned,
   ep.recurrency_type as expense_plan_recurrency_type,
   ep.recurrency_interval as expense_plan_recurrency_interval
FROM expense_plan_record rec
LEFT JOIN expense_plan ep ON rec.expense_plan_id = ep.expense_plan_id
`

type ListExpensePlanRecordsRow struct {
	ExpensePlanRecordID           int32
	ExpensePlanID                 int32
	AmountPaid                    int32
	PaymentDate                   pgtype.Timestamptz
	PaidDate                      pgtype.Timestamptz
	ExpensePlanSequence           int32
	CreatedAt                     pgtype.Timestamptz
	UpdatedAt                     pgtype.Timestamptz
	ExpensePlanTitle              pgtype.Text
	ExpensePlanCategory           NullExpensePlanCategory
	ExpensePlanAmountPlanned      pgtype.Int4
	ExpensePlanRecurrencyType     NullRecurrencyType
	ExpensePlanRecurrencyInterval pgtype.Int4
}

func (q *Queries) ListExpensePlanRecords(ctx context.Context) ([]ListExpensePlanRecordsRow, error) {
	rows, err := q.db.Query(ctx, listExpensePlanRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpensePlanRecordsRow
	for rows.Next() {
		var i ListExpensePlanRecordsRow
		if err := rows.Scan(
			&i.ExpensePlanRecordID,
			&i.ExpensePlanID,
			&i.AmountPaid,
			&i.PaymentDate,
			&i.PaidDate,
			&i.ExpensePlanSequence,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpensePlanTitle,
			&i.ExpensePlanCategory,
			&i.ExpensePlanAmountPlanned,
			&i.ExpensePlanRecurrencyType,
			&i.ExpensePlanRecurrencyInterval,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpensePlans = `-- name: ListExpensePlans :many
SELECT 
   pla.expense_plan_id, pla.title, pla.amount_planned, pla.recurrency_type, pla.recurrency_interval, pla.category, pla.created_at, pla.updated_at, pla.first_expense_plan_record_id, pla.last_expense_plan_record_id,
   frec.amount_paid as first_amount_paid,
   frec.payment_date as first_payment_date,
   frec.paid_date as first_paid_date,
   frec.expense_plan_sequence as first_expense_plan_sequence,
   lrec.amount_paid as last_amount_paid,
   lrec.payment_date as last_payment_date,
   lrec.paid_date as last_paid_date,
   lrec.expense_plan_sequence as last_expense_plan_sequence
FROM expense_plan pla
LEFT JOIN expense_plan_record frec ON pla.first_expense_plan_record_id = frec.expense_plan_record_id
LEFT JOIN expense_plan_record lrec ON pla.last_expense_plan_record_id = lrec.expense_plan_record_id
`

type ListExpensePlansRow struct {
	ExpensePlanID            int32
	Title                    string
	AmountPlanned            int32
	RecurrencyType           NullRecurrencyType
	RecurrencyInterval       int32
	Category                 ExpensePlanCategory
	CreatedAt                pgtype.Timestamptz
	UpdatedAt                pgtype.Timestamptz
	FirstExpensePlanRecordID pgtype.Int4
	LastExpensePlanRecordID  pgtype.Int4
	FirstAmountPaid          pgtype.Int4
	FirstPaymentDate         pgtype.Timestamptz
	FirstPaidDate            pgtype.Timestamptz
	FirstExpensePlanSequence pgtype.Int4
	LastAmountPaid           pgtype.Int4
	LastPaymentDate          pgtype.Timestamptz
	LastPaidDate             pgtype.Timestamptz
	LastExpensePlanSequence  pgtype.Int4
}

func (q *Queries) ListExpensePlans(ctx context.Context) ([]ListExpensePlansRow, error) {
	rows, err := q.db.Query(ctx, listExpensePlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListExpensePlansRow
	for rows.Next() {
		var i ListExpensePlansRow
		if err := rows.Scan(
			&i.ExpensePlanID,
			&i.Title,
			&i.AmountPlanned,
			&i.RecurrencyType,
			&i.RecurrencyInterval,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstExpensePlanRecordID,
			&i.LastExpensePlanRecordID,
			&i.FirstAmountPaid,
			&i.FirstPaymentDate,
			&i.FirstPaidDate,
			&i.FirstExpensePlanSequence,
			&i.LastAmountPaid,
			&i.LastPaymentDate,
			&i.LastPaidDate,
			&i.LastExpensePlanSequence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpensePlan = `-- name: UpdateExpensePlan :one
UPDATE expense_plan SET
   title = $1,
   category = $2,
   amount_planned = $3,
   recurrency_type = $4,
   recurrency_interval = $5,
   updated_at = NOW()
WHERE expense_plan_id = $6
RETURNING expense_plan_id, title, amount_planned, recurrency_type, recurrency_interval, category, created_at, updated_at, first_expense_plan_record_id, last_expense_plan_record_id
`

type UpdateExpensePlanParams struct {
	Title              string
	Category           NullExpensePlanCategory
	AmountPlanned      int32
	RecurrencyType     NullRecurrencyType
	RecurrencyInterval int32
	ExpensePlanID      int32
}

func (q *Queries) UpdateExpensePlan(ctx context.Context, arg UpdateExpensePlanParams) (ExpensePlan, error) {
	row := q.db.QueryRow(ctx, updateExpensePlan,
		arg.Title,
		arg.Category,
		arg.AmountPlanned,
		arg.RecurrencyType,
		arg.RecurrencyInterval,
		arg.ExpensePlanID,
	)
	var i ExpensePlan
	err := row.Scan(
		&i.ExpensePlanID,
		&i.Title,
		&i.AmountPlanned,
		&i.RecurrencyType,
		&i.RecurrencyInterval,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstExpensePlanRecordID,
		&i.LastExpensePlanRecordID,
	)
	return i, err
}

const updateExpensePlanAfterRecord = `-- name: UpdateExpensePlanAfterRecord :one
UPDATE expense_plan SET
   first_expense_plan_record_id = COALESCE((
      SELECT r.expense_plan_record_id
      FROM expense_plan_record r
      WHERE r.expense_plan_id = $1
      ORDER BY r.payment_date ASC
      LIMIT 1
   ), NULL),
   last_expense_plan_record_id = COALESCE((
      SELECT r.expense_plan_record_id
      FROM expense_plan_record r
      WHERE r.expense_plan_id = $1
      ORDER BY r.payment_date DESC
      LIMIT 1
   ), NULL),
   updated_at = NOW()
WHERE expense_plan_id = $1
RETURNING expense_plan_id, title, amount_planned, recurrency_type, recurrency_interval, category, created_at, updated_at, first_expense_plan_record_id, last_expense_plan_record_id
`

func (q *Queries) UpdateExpensePlanAfterRecord(ctx context.Context, expensePlanID int32) (ExpensePlan, error) {
	row := q.db.QueryRow(ctx, updateExpensePlanAfterRecord, expensePlanID)
	var i ExpensePlan
	err := row.Scan(
		&i.ExpensePlanID,
		&i.Title,
		&i.AmountPlanned,
		&i.RecurrencyType,
		&i.RecurrencyInterval,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FirstExpensePlanRecordID,
		&i.LastExpensePlanRecordID,
	)
	return i, err
}

const updateExpensePlanRecord = `-- name: UpdateExpensePlanRecord :one
UPDATE expense_plan_record SET
   expense_plan_id = $1,
   amount_paid = $2,
   payment_date = $3,
   paid_date = $4,
   expense_plan_sequence = COALESCE((
      SELECT r.expense_plan_sequence
      FROM expense_plan_record r
      WHERE r.expense_plan_id = $1
      AND r.payment_date      < $3
      ORDER BY r.payment_date DESC
      LIMIT 1
   ), 0) + 1,
   updated_at = NOW()
WHERE expense_plan_record_id = $5
RETURNING expense_plan_record_id, expense_plan_id, amount_paid, payment_date, paid_date, expense_plan_sequence, created_at, updated_at
`

type UpdateExpensePlanRecordParams struct {
	ExpensePlanID       pgtype.Int4
	AmountPaid          pgtype.Int4
	PaymentDate         pgtype.Timestamptz
	PaidDate            pgtype.Timestamptz
	ExpensePlanRecordID pgtype.Int4
}

func (q *Queries) UpdateExpensePlanRecord(ctx context.Context, arg UpdateExpensePlanRecordParams) (ExpensePlanRecord, error) {
	row := q.db.QueryRow(ctx, updateExpensePlanRecord,
		arg.ExpensePlanID,
		arg.AmountPaid,
		arg.PaymentDate,
		arg.PaidDate,
		arg.ExpensePlanRecordID,
	)
	var i ExpensePlanRecord
	err := row.Scan(
		&i.ExpensePlanRecordID,
		&i.ExpensePlanID,
		&i.AmountPaid,
		&i.PaymentDate,
		&i.PaidDate,
		&i.ExpensePlanSequence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
